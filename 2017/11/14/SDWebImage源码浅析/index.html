<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>SDWebImage源码浅析 | 夜满西楼的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SDWebImage源码浅析</h1><a id="logo" href="/.">夜满西楼的博客</a><p class="description">运气就是机会碰巧撞到了你的努力。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SDWebImage源码浅析</h1><div class="post-meta">Nov 14, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" data-disqus-identifier="2017/11/14/SDWebImage源码浅析/" href="/2017/11/14/SDWebImage源码浅析/#disqus_thread"></a><div class="post-content"><blockquote>
<p>1、平时开发的过程中用到过三方库吗？<br>2、使用三方库的过程中遇到过什么问题吗？<br>3、有读过优秀三方的源码么？<br>4、知道三方库底层怎么实现的吗？</p>
</blockquote>
<p>####写在开始之前<br>在很多水友相亲的过程中，经常会被问到类似的问题，有些人能够言简意赅的把某框架的优缺点表达出来<code>（心中：我凑，还好我昨天背了一下，这个逼我一定要装好）</code>，有些人却还是停留在简单使用API的阶段，具体怎么实现却支支吾吾的说不清楚<code>（心中万马奔腾，麻痹的，这么底层的东西也要问吗？）</code>。<br><a id="more"></a><br>iOS日常开发中，常用的开源三方库有很多<strong>AFNetworking、SDWebImage、MJRefresh、YYKit系列</strong>等，今天我们就先来说说<strong>SDWebImage</strong>。<br>SDWebImage的源码第一次看还是大概2年前，当时还是用的<code>NSURLConnection</code>来下载图片的，时光荏苒，SDWebImage早已改变成了<code>NSURLSession</code>来下载图片，并且不断的优化，Github也多了1W多Star，而我还是当年那个小菜逼，说多了都是眼泪<img src="http://upload-images.jianshu.io/upload_images/1890873-d9f364347ec38dff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>最近一次面试的时候，被问到一个问题，<br>面试官：UITableView的5个cell同时下载一个<strong>相同</strong>图片，SDWebImage底层怎么处理的？<br>我：之前看过，记不清了（当时我的表情是懵逼的，之前只是草草的看过一遍，而且还有很多地方都看不懂）<br>面试官：没关系，如果要是你自己做，你会怎么做？<br>我：弄一个串行队列，第一个任务下载完之后，缓存，然后后边的任务就可以直接取缓存<br>面试官：如果我同时需要5个图片的下载进度呢？<br>我：当是真心有点凌乱了，然后思（懵）考（逼）了2分钟<br>面试官：好吧，今天的面试就先到这里吧</p>
</blockquote>
<p>带着面试的问题，我老老实实的又从GitHub上下载个<strong>SDWebImage-4.2.2</strong>，花了一天的时间，又看了一遍，现在把看明白的东西记录一下。</p>
<p>####1、SDWebImage工作流程<br><img src="http://upload-images.jianshu.io/upload_images/1890873-f02491a8dd96100e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这是GitHub上提供的，我顺手给牵了过来，再说了，文化人的事，能叫偷么？"><br><img src="http://upload-images.jianshu.io/upload_images/1890873-47307427ee4083be.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>虽然SDWebImage的主要工作流程很多水友都能说出个大概，我还是简单说一下我的理解吧，像我这种大龄程序员，说不定哪天就忘了，将来还能回来翻翻笔记。</p>
<blockquote>
<p><strong>Step1</strong>：调用加载图片API  <code>sd_setImageWithURL:</code> 系列<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">imageView</span> sd_setImageWithURL:[<span class="name">NSURL</span>  URLWithString:@<span class="string">"http://www.domain.com/path/to/image.jpg"</span>]</span><br><span class="line">            placeholderImage:[<span class="name">UIImage</span> imageNamed:@<span class="string">"placeholder.png"</span>]]<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>调用API之后，SDWebImage会判断是否显示占位图，如果让显示就先显示占位图</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果options != SDWebImageDelayPlaceholder</span></span><br><span class="line"><span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [self <span class="string">sd_setImage:</span>placeholder <span class="string">imageData:</span>nil <span class="string">basedOnClassOrViaCustomSetImageBlock:</span>setImageBlock];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>写到这里再啰嗦几句，说出来你可能不信，<code>options &amp; SDWebImageDelayPlaceholder</code>这种写法，在昨天之前我是看不懂的，看到逻辑与&amp;，我努力回想了下当年的秃顶计算机老师是怎么讲的，但是没想起来，后来琢磨了下，应该是<code>0 &amp; 0 = 0, 1 &amp; 0 = 0, 1 &amp; 1 = 1</code>，结合<code>SDWebImageDelayPlaceholder</code>的定义<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> * By default, placeholder images are loaded <span class="keyword">while</span> <span class="keyword">the</span> image is loading. This flag will delay <span class="keyword">the</span> loading</span><br><span class="line"> * <span class="keyword">of</span> <span class="keyword">the</span> placeholder image <span class="keyword">until</span> <span class="keyword">after</span> <span class="keyword">the</span> image has finished loading.</span><br><span class="line"> */</span><br><span class="line">SDWebImageDelayPlaceholder = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,</span><br></pre></td></tr></table></figure></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">9</span> ==&gt; <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> &lt;&lt; <span class="number">9</span> ==&gt; <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">假设options = SDWebImageRetryFailed = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">options &amp; SDWebImageDelayPlaceholder </span><br><span class="line">==&gt;    <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> </span><br><span class="line">    &amp;  <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">===========================</span><br><span class="line">       <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>  = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">假设options = SDWebImageDelayPlaceholder  = <span class="number">1</span> &lt;&lt; <span class="number">9</span></span><br><span class="line">options &amp; SDWebImageDelayPlaceholder </span><br><span class="line">==&gt;    <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span> </span><br><span class="line">    &amp;  <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">=========================== </span><br><span class="line">       <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span>  = <span class="number">1</span> &lt;&lt; <span class="number">9</span> = !<span class="number">0</span></span><br><span class="line"></span><br><span class="line">option逻辑与（&amp;）上自己本身结果是自己，非零，options逻辑与（&amp;）上非自身的其他枚举值，结果都是<span class="number">0</span>，这个逻辑于（&amp;）在这里跟 == 的作用是一样的，就是判断options的枚举值，</span><br><span class="line">options &amp; SDWebImageDelayPlaceholder ==&gt; options == SDWebImageDelayPlaceholder</span><br><span class="line">what the fk? </span><br><span class="line">原来只是个options == SDWebImageDelayPlaceholder判断，哎，都是吃文化低的亏，啰嗦了这么多也不知道表达清楚没。</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Step2</strong>：SDImageCache以URL为key在imageCache中查找图片</p>
</blockquote>
<p>首先在memCache中查找，如果能找到image，执行回调block，把image传回去，如果memCache中没有找到，会开启一个异步线程去磁盘上查找，如果找到image，保存到memCache中，如果没有找到，返回nil，查找完成。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First check the in-memory cache...</span></span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line"><span class="keyword">if</span> (image) &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *diskData = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (image.images) &#123;</span><br><span class="line">        diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">        doneBlock(image, diskData, SDImageCacheTypeMemory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</span><br><span class="line"><span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">    <span class="keyword">if</span> (operation.isCancelled) &#123;</span><br><span class="line">        <span class="comment">// do not call the completion if cancelled</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">        <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</span><br><span class="line">        <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">            <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</span><br><span class="line">            [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Step3</strong>：SDWebImageDownloader下载图片</p>
</blockquote>
<p>如果内存和磁盘上都没有查询到URLString对应的image，就会让imageDownloader去下载图片，根据URL创建一个request，然后根据request创建一个sessionTask开始下载<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">NSTimeInterval <span class="attr">timeoutInterval</span> = sself.downloadTimeout;</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">timeoutInterval</span> == <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="attr">timeoutInterval</span> = <span class="number">15.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests <span class="keyword">if</span> told otherwise</span><br><span class="line">NSURLRequestCachePolicy <span class="attr">cachePolicy</span> = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;</span><br><span class="line">NSMutableURLRequest *<span class="attr">request</span> = [[NSMutableURLRequest alloc] initWithURL:url</span><br><span class="line">                                                            cachePolicy:cachePolicy</span><br><span class="line">                                                        timeoutInterval:timeoutInterval];</span><br><span class="line"></span><br><span class="line">request.<span class="attr">HTTPShouldHandleCookies</span> = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">request.<span class="attr">HTTPShouldUsePipelining</span> = YES;</span><br><span class="line"><span class="keyword">if</span> (sself.headersFilter) &#123;</span><br><span class="line">    request.<span class="attr">allHTTPHeaderFields</span> = sself.headersFilter(url, [sself.HTTPHeaders copy]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    request.<span class="attr">allHTTPHeaderFields</span> = sself.HTTPHeaders;</span><br><span class="line">&#125;</span><br><span class="line">SDWebImageDownloaderOperation *<span class="attr">operation</span> = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</span><br><span class="line">operation.<span class="attr">shouldDecompressImages</span> = sself.shouldDecompressImages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sself.urlCredential) &#123;</span><br><span class="line">    operation.<span class="attr">credential</span> = sself.urlCredential;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</span><br><span class="line">    operation.<span class="attr">credential</span> = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">    operation.<span class="attr">queuePriority</span> = NSOperationQueuePriorityHigh;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">    operation.<span class="attr">queuePriority</span> = NSOperationQueuePriorityLow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[sself.downloadQueue addOperation:operation];</span><br></pre></td></tr></table></figure></p>
<p>operation添加到operationQueue中，自动开启下载任务，下载的过程中通过进度block回传下载进度，下载完成后解码转码，调用下载完成回调block把image对象回传。</p>
<blockquote>
<p><strong>Step4</strong>：SDImageCache存储图片</p>
</blockquote>
<p>默认转码后的图片会缓存到内存中，如果同时需要缓存到磁盘上，才会开启异步IO队列通过NSFileManager把图片写入到本地磁盘，磁盘上图片的名字是经过MD5处理后的URLString。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if memory cache is enabled</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);</span><br><span class="line">    [<span class="keyword">self</span>.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (toDisk) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="built_in">NSData</span> *data = imageData;</span><br><span class="line">            <span class="keyword">if</span> (!data &amp;&amp; image) &#123;</span><br><span class="line">                <span class="comment">// If we do not have any data to detect image format, use PNG format</span></span><br><span class="line">                data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:SDImageFormatPNG];</span><br><span class="line">            &#125;</span><br><span class="line">            [<span class="keyword">self</span> storeImageDataToDisk:data forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)storeImageDataToDisk:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!imageData || !key) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> checkIfQueueIsIOQueue];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">        [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get cache Path for image key</span></span><br><span class="line">    <span class="built_in">NSString</span> *cachePathForKey = [<span class="keyword">self</span> defaultCachePathForKey:key];</span><br><span class="line">    <span class="comment">// transform to NSUrl</span></span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:cachePathForKey];</span><br><span class="line">    </span><br><span class="line">    [_fileManager createFileAtPath:cachePathForKey contents:imageData attributes:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// disable iCloud backup</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldDisableiCloud) &#123;</span><br><span class="line">        [fileURL setResourceValue:@YES forKey:<span class="built_in">NSURLIsExcludedFromBackupKey</span> error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>这就是SDWebImage加载一张图片的大致流程了，其实SDWebImage里面做了很多细节优化处理。让我们接着往下look</strong></p>
</blockquote>
<p>####3、SDWebImage底层优化</p>
<ul>
<li>1、无效URL的处理<br><code>@property (strong, nonatomic, nonnull) NSMutableSet&lt;NSURL *&gt; *failedURLs;</code><br>SDWebImageManager维护了一个黑名单存放图片下载失败的URL，每次根据URLString查询图片的时候，会先去黑名单中查询，目标URL是否在黑名单中<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        <span class="comment">//为了线程安全</span></span><br><span class="line">        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</span><br><span class="line">            isFailedUrl = [<span class="keyword">self</span>.failedURLs containsObject:url];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果URL在黑名单中，直接执行回调Block，回传error，提高效率，避免不必要的操作。如果不被黑名单包含，继续正常流程，对应的URL下载失败后，把URL添加到黑名单<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (   <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorNotConnectedToInternet</span><br><span class="line">    &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorCancelled</span><br><span class="line">    &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorTimedOut</span><br><span class="line">    &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorInternationalRoamingOff</span><br><span class="line">    &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorDataNotAllowed</span><br><span class="line">    &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorCannotFindHost</span><br><span class="line">    &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorCannotConnectToHost</span><br><span class="line">    &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorNetworkConnectionLost) &#123;</span><br><span class="line">    <span class="comment">@synchronized (self.failedURLs) &#123;</span></span><br><span class="line"><span class="comment">        [self.failedURLs addObject:url];</span></span><br><span class="line"><span class="comment">   &#125; </span></span><br><span class="line"><span class="comment"> &#125;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>2、高并发相同URL请求的处理<br><code>@property (strong, nonatomic, nonnull) NSMutableDictionary&lt;NSURL *, SDWebImageDownloaderOperation *&gt; *URLOperations;</code><br>SD内部每一个下载请求，对应一个SDWebImageDownloaderOperation，SDWebImageDownloader通过URLOperations属性来维护这个operation。<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</span><br><span class="line">    <span class="comment">//根据URLString查询是否有正在下载的操作</span></span><br><span class="line">    SDWebImageDownloaderOperation *operation = <span class="keyword">self</span>.URLOperations[url];</span><br><span class="line">    <span class="keyword">if</span> (!operation) &#123;</span><br><span class="line">        operation = createCallback();</span><br><span class="line">        <span class="comment">//把下载操作添加到URLOperations中</span></span><br><span class="line">        <span class="keyword">self</span>.URLOperations[url] = operation;</span><br><span class="line"></span><br><span class="line">        __<span class="keyword">weak</span> SDWebImageDownloaderOperation *woperation = operation;</span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line">            dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</span><br><span class="line">                SDWebImageDownloaderOperation *soperation = woperation;</span><br><span class="line">                <span class="keyword">if</span> (!soperation) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.URLOperations[url] == soperation) &#123;</span><br><span class="line">                    <span class="comment">//下完成后，把该URL的下载操作从URLOperations移除</span></span><br><span class="line">                    [<span class="keyword">self</span>.URLOperations removeObjectForKey:url];</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//已经有该URLString对应的下载任务存在，保存新任务的进度回调block和完成回调block</span></span><br><span class="line">    <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line"></span><br><span class="line">    token = [SDWebImageDownloadToken new];</span><br><span class="line">    token.url = url;</span><br><span class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在<code>NSURLSessionDataDelegate</code>的<code>- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data</code>方法中可以看到如下代码<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> <span class="symbol">callbacksForKey:</span>kProgressCallbackKey]) &#123;</span><br><span class="line">    /<span class="regexp">/循环执行相同URL的进度回调Block</span></span><br><span class="line"><span class="regexp">    progressBlock(self.imageData.length, self.expectedSize, self.request.URL);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>简单的说，就是相同的URL只开启一个下载任务，在下载的过程中，把下载进度分别通知给该URL对应的其他操作，既节约流量、又兼顾所有任务的下载进度。下载完成的回调block同理执行。</p>
<ul>
<li>3、高并发不同URL请求的处理<br>UITableView的多个cell同时加载图片的时候，就会出现高并发的情况<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认最大并发数</span></span><br><span class="line">_downloadQueue.maxConcurrentOperationCount = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//session的初始化</span></span><br><span class="line"><span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfiguration</span><br><span class="line">                                                 delegate:<span class="keyword">self</span></span><br><span class="line">                                            delegateQueue:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>系统API对delegateQueue参数的描述是<code>If nil, the session creates a serial operation queue for performing all delegate method calls and completion handler calls.</code><br>SDWebImage的高并发下载任务是在一个并行队列，默认支持最大的并发数是6，默认并发任务执行顺序是FIFO（first in first out），如果设置任务的执行顺序为LIFO（last in first out）<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">    <span class="regexp">//</span> Emulate LIFO execution order <span class="keyword">by</span> systematically adding <span class="keyword">new</span> operations <span class="keyword">as</span> last operation<span class="string">'s dependency</span></span><br><span class="line"><span class="string">    //设置操作之间的依赖，新添加的operation被旧的operation依赖，来实现后进先出</span></span><br><span class="line"><span class="string">    [sself.lastAddedOperation addDependency:operation];</span></span><br><span class="line"><span class="string">    sself.lastAddedOperation = operation;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><code>SDWebImageDownloader</code>在接收到<code>NSURLSessionDataDelegate</code>代理方法回调的时候，通过<code>NSURLSessionDataTask</code>获取到对应的<code>SDWebImageDownloaderOperation</code>，把delegate方法转发给<code>SDWebImageDownloaderOperation</code>，避免数据错乱。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">URLSession:</span>(NSURLSession *)session <span class="string">dataTask:</span>(NSURLSessionDataTask *)dataTask <span class="string">didReceiveData:</span>(NSData *)data &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self <span class="string">operationWithTask:</span>dataTask];</span><br><span class="line">    <span class="comment">//把代理方法转发给SDWebImageDownloaderOperation</span></span><br><span class="line">    [dataOperation <span class="string">URLSession:</span>session <span class="string">dataTask:</span>dataTask <span class="string">didReceiveData:</span>data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据NSURLSessionTask获取对应的SDWebImageDownloaderOperation</span></span><br><span class="line">- (SDWebImageDownloaderOperation *)<span class="string">operationWithTask:</span>(NSURLSessionTask *)task &#123;</span><br><span class="line">    SDWebImageDownloaderOperation *returnOperation = nil;</span><br><span class="line">    <span class="keyword">for</span> (SDWebImageDownloaderOperation *operation <span class="keyword">in</span> self.downloadQueue.operations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operation.dataTask.taskIdentifier == task.taskIdentifier) &#123;</span><br><span class="line">            returnOperation = operation;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnOperation;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<ul>
<li>4、缓存管理策略<br>SDWebImage的内存管理由SDImageCache负责，分别监听了<strong>内存警告、应用将释放、进入后台</strong>三个通知<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span></span><br><span class="line">                                         <span class="selector-tag">selector</span>:@<span class="keyword">selector</span>(<span class="keyword">clearMemory</span>)</span><br><span class="line">                                             name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                           object:nil];</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span></span><br><span class="line">                                         <span class="selector-tag">selector</span>:@<span class="keyword">selector</span>(<span class="keyword">deleteOldFiles</span>)</span><br><span class="line">                                             name:UIApplicationWillTerminateNotification</span><br><span class="line">                                           object:nil];</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span></span><br><span class="line">                                         <span class="selector-tag">selector</span>:@<span class="keyword">selector</span>(<span class="keyword">backgroundDeleteOldFiles</span>)</span><br><span class="line">                                             name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                           object:nil];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到内存警告通知，把内存中缓存的图片清空</span></span><br><span class="line">- (<span class="keyword">void</span>)clearMemory &#123;</span><br><span class="line">    [<span class="meta">self.memCache removeAllObjects</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SDImageCache图片磁盘缓存的时长默认是1周<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static const NSInteger kDefaultCacheMaxCacheAge = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>; <span class="comment">// 1 week</span></span><br></pre></td></tr></table></figure></p>
<p>在每次收到<strong>进入后台、应用将要释放</strong>通知后，SDWebImage会检查磁盘上的图片，如果过期就清理<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove files that are older than the expiration date;</span></span><br><span class="line"><span class="comment">//如果图片过期，记录过期图片URL</span></span><br><span class="line">NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];</span><br><span class="line"><span class="keyword">if</span> ([[modificationDate <span class="string">laterDate:</span>expirationDate] <span class="string">isEqualToDate:</span>expirationDate]) &#123;</span><br><span class="line">    [urlsToDelete <span class="string">addObject:</span>fileURL];</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环删除过期图片</span></span><br><span class="line"><span class="keyword">for</span> (NSURL *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</span><br><span class="line">    [_fileManager <span class="string">removeItemAtURL:</span>fileURL <span class="string">error:</span>nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果设置最大的缓存空间，在收到<strong>进入后台、应用将要释放</strong>通知后，判断使用当前空间使用超过设置的最大空间的50%后，开始清理，按照修改时间排序后，从修改时间最早的开始清理，直到使用空间小于缓存空间50%后结束。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If our remaining disk cache exceeds a configured maximum size, perform a second</span></span><br><span class="line"><span class="comment">// size-based cleanup pass.  We delete the oldest files first.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.config.maxCacheSize &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span>.config.maxCacheSize) &#123;</span><br><span class="line">    <span class="comment">// Target half of our maximum cache size for this cleanup pass.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span>.config.maxCacheSize / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sort the remaining cache files by their last modification time (oldest first).</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></span><br><span class="line">                                                             usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</span><br><span class="line">                                                                 <span class="keyword">return</span> [obj1[<span class="built_in">NSURLContentModificationDateKey</span>] compare:obj2[<span class="built_in">NSURLContentModificationDateKey</span>]];</span><br><span class="line">                                                             &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete files until we fall below our desired cache size.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *resourceValues = cacheFiles[fileURL];</span><br><span class="line">            <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">            currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>5、解码转码<br><img src="http://upload-images.jianshu.io/upload_images/1890873-737b0832f74ae9a8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<p>说实话，解码转码这块看的还不太明白，等我看明白了，再回来补上…</p>
</div><div class="tags"><a href="/tags/iOS/">iOS</a></div><div class="post-nav"><a class="next" href="/2017/03/17/UIWebView的加载进度条/">UIWebView的加载进度条</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://yoursite.com/2017/11/14/SDWebImage源码浅析/';
    this.page.identifier = '2017/11/14/SDWebImage源码浅析/';
    this.page.title = 'SDWebImage源码浅析';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//https-dengkej-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//https-dengkej-github-io.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://https-dengkej-github-io.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/iOS/" style="font-size: 15px;">iOS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/14/SDWebImage源码浅析/">SDWebImage源码浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/17/UIWebView的加载进度条/">UIWebView的加载进度条</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/11/iOS 文本高度计算/">iOS 文本高度计算</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//https-dengkej-github-io.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/DengkeJ" title="Github" target="_blank">Github</a><ul></ul><a href="http://boaihome.com" title="博爱1616的博客" target="_blank">博爱1616的博客</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">夜满西楼的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>