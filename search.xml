<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>SDWebImage源码浅析</title>
      <link href="/2017/11/14/SDWebImage%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
      <url>/2017/11/14/SDWebImage%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote><p>1、平时开发的过程中用到过三方库吗？<br>2、使用三方库的过程中遇到过什么问题吗？<br>3、有读过优秀三方的源码么？<br>4、知道三方库底层怎么实现的吗？</p></blockquote><p>####写在开始之前<br>在很多水友相亲的过程中，经常会被问到类似的问题，有些人能够言简意赅的把某框架的优缺点表达出来<code>（心中：我凑，还好我昨天背了一下，这个逼我一定要装好）</code>，有些人却还是停留在简单使用API的阶段，具体怎么实现却支支吾吾的说不清楚<code>（心中万马奔腾，麻痹的，这么底层的东西也要问吗？）</code>。<br><a id="more"></a><br>iOS日常开发中，常用的开源三方库有很多<strong>AFNetworking、SDWebImage、MJRefresh、YYKit系列</strong>等，今天我们就先来说说<strong>SDWebImage</strong>。<br>SDWebImage的源码第一次看还是大概2年前，当时还是用的<code>NSURLConnection</code>来下载图片的，时光荏苒，SDWebImage早已改变成了<code>NSURLSession</code>来下载图片，并且不断的优化，Github也多了1W多Star，而我还是当年那个小菜逼，说多了都是眼泪<img src="http://upload-images.jianshu.io/upload_images/1890873-d9f364347ec38dff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>最近一次面试的时候，被问到一个问题，<br>面试官：UITableView的5个cell同时下载一个<strong>相同</strong>图片，SDWebImage底层怎么处理的？<br>我：之前看过，记不清了（当时我的表情是懵逼的，之前只是草草的看过一遍，而且还有很多地方都看不懂）<br>面试官：没关系，如果要是你自己做，你会怎么做？<br>我：弄一个串行队列，第一个任务下载完之后，缓存，然后后边的任务就可以直接取缓存<br>面试官：如果我同时需要5个图片的下载进度呢？<br>我：当是真心有点凌乱了，然后思（懵）考（逼）了2分钟<br>面试官：好吧，今天的面试就先到这里吧</p></blockquote><p>带着面试的问题，我老老实实的又从GitHub上下载个<strong>SDWebImage-4.2.2</strong>，花了一天的时间，又看了一遍，现在把看明白的东西记录一下。</p><p>####1、SDWebImage工作流程<br><img src="http://upload-images.jianshu.io/upload_images/1890873-f02491a8dd96100e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这是GitHub上提供的，我顺手给牵了过来，再说了，文化人的事，能叫偷么？"><br><img src="http://upload-images.jianshu.io/upload_images/1890873-47307427ee4083be.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>虽然SDWebImage的主要工作流程很多水友都能说出个大概，我还是简单说一下我的理解吧，像我这种大龄程序员，说不定哪天就忘了，将来还能回来翻翻笔记。</p><blockquote><p><strong>Step1</strong>：调用加载图片API  <code>sd_setImageWithURL:</code> 系列<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">imageView</span> sd_setImageWithURL:[<span class="name">NSURL</span>  URLWithString:@<span class="string">"http://www.domain.com/path/to/image.jpg"</span>]</span><br><span class="line">            placeholderImage:[<span class="name">UIImage</span> imageNamed:@<span class="string">"placeholder.png"</span>]]<span class="comment">;</span></span><br></pre></td></tr></table></figure></p></blockquote><p>调用API之后，SDWebImage会判断是否显示占位图，如果让显示就先显示占位图</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果options != SDWebImageDelayPlaceholder</span></span><br><span class="line"><span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [self <span class="string">sd_setImage:</span>placeholder <span class="string">imageData:</span>nil <span class="string">basedOnClassOrViaCustomSetImageBlock:</span>setImageBlock];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>写到这里再啰嗦几句，说出来你可能不信，<code>options &amp; SDWebImageDelayPlaceholder</code>这种写法，在昨天之前我是看不懂的，看到逻辑与&amp;，我努力回想了下当年的秃顶计算机老师是怎么讲的，但是没想起来，后来琢磨了下，应该是<code>0 &amp; 0 = 0, 1 &amp; 0 = 0, 1 &amp; 1 = 1</code>，结合<code>SDWebImageDelayPlaceholder</code>的定义<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> * By default, placeholder images are loaded <span class="keyword">while</span> <span class="keyword">the</span> image is loading. This flag will delay <span class="keyword">the</span> loading</span><br><span class="line"> * <span class="keyword">of</span> <span class="keyword">the</span> placeholder image <span class="keyword">until</span> <span class="keyword">after</span> <span class="keyword">the</span> image has finished loading.</span><br><span class="line"> */</span><br><span class="line">SDWebImageDelayPlaceholder = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,</span><br></pre></td></tr></table></figure></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">9</span> ==&gt; <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> &lt;&lt; <span class="number">9</span> ==&gt; <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">假设options = SDWebImageRetryFailed = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">options &amp; SDWebImageDelayPlaceholder </span><br><span class="line">==&gt;    <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> </span><br><span class="line">    &amp;  <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">===========================</span><br><span class="line">       <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>  = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">假设options = SDWebImageDelayPlaceholder  = <span class="number">1</span> &lt;&lt; <span class="number">9</span></span><br><span class="line">options &amp; SDWebImageDelayPlaceholder </span><br><span class="line">==&gt;    <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span> </span><br><span class="line">    &amp;  <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">=========================== </span><br><span class="line">       <span class="number">0000</span> <span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span>  = <span class="number">1</span> &lt;&lt; <span class="number">9</span> = !<span class="number">0</span></span><br><span class="line"></span><br><span class="line">option逻辑与（&amp;）上自己本身结果是自己，非零，options逻辑与（&amp;）上非自身的其他枚举值，结果都是<span class="number">0</span>，这个逻辑于（&amp;）在这里跟 == 的作用是一样的，就是判断options的枚举值，</span><br><span class="line">options &amp; SDWebImageDelayPlaceholder ==&gt; options == SDWebImageDelayPlaceholder</span><br><span class="line">what the fk? </span><br><span class="line">原来只是个options == SDWebImageDelayPlaceholder判断，哎，都是吃文化低的亏，啰嗦了这么多也不知道表达清楚没。</span><br></pre></td></tr></table></figure><blockquote><p><strong>Step2</strong>：SDImageCache以URL为key在imageCache中查找图片</p></blockquote><p>首先在memCache中查找，如果能找到image，执行回调block，把image传回去，如果memCache中没有找到，会开启一个异步线程去磁盘上查找，如果找到image，保存到memCache中，如果没有找到，返回nil，查找完成。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First check the in-memory cache...</span></span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line"><span class="keyword">if</span> (image) &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *diskData = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (image.images) &#123;</span><br><span class="line">        diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">        doneBlock(image, diskData, SDImageCacheTypeMemory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</span><br><span class="line"><span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">    <span class="keyword">if</span> (operation.isCancelled) &#123;</span><br><span class="line">        <span class="comment">// do not call the completion if cancelled</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">        <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</span><br><span class="line">        <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">            <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</span><br><span class="line">            [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>Step3</strong>：SDWebImageDownloader下载图片</p></blockquote><p>如果内存和磁盘上都没有查询到URLString对应的image，就会让imageDownloader去下载图片，根据URL创建一个request，然后根据request创建一个sessionTask开始下载<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">NSTimeInterval <span class="attr">timeoutInterval</span> = sself.downloadTimeout;</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">timeoutInterval</span> == <span class="number">0.0</span>) &#123;</span><br><span class="line">    <span class="attr">timeoutInterval</span> = <span class="number">15.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests <span class="keyword">if</span> told otherwise</span><br><span class="line">NSURLRequestCachePolicy <span class="attr">cachePolicy</span> = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;</span><br><span class="line">NSMutableURLRequest *<span class="attr">request</span> = [[NSMutableURLRequest alloc] initWithURL:url</span><br><span class="line">                                                            cachePolicy:cachePolicy</span><br><span class="line">                                                        timeoutInterval:timeoutInterval];</span><br><span class="line"></span><br><span class="line">request.<span class="attr">HTTPShouldHandleCookies</span> = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">request.<span class="attr">HTTPShouldUsePipelining</span> = YES;</span><br><span class="line"><span class="keyword">if</span> (sself.headersFilter) &#123;</span><br><span class="line">    request.<span class="attr">allHTTPHeaderFields</span> = sself.headersFilter(url, [sself.HTTPHeaders copy]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    request.<span class="attr">allHTTPHeaderFields</span> = sself.HTTPHeaders;</span><br><span class="line">&#125;</span><br><span class="line">SDWebImageDownloaderOperation *<span class="attr">operation</span> = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</span><br><span class="line">operation.<span class="attr">shouldDecompressImages</span> = sself.shouldDecompressImages;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sself.urlCredential) &#123;</span><br><span class="line">    operation.<span class="attr">credential</span> = sself.urlCredential;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</span><br><span class="line">    operation.<span class="attr">credential</span> = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">    operation.<span class="attr">queuePriority</span> = NSOperationQueuePriorityHigh;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">    operation.<span class="attr">queuePriority</span> = NSOperationQueuePriorityLow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[sself.downloadQueue addOperation:operation];</span><br></pre></td></tr></table></figure></p><p>operation添加到operationQueue中，自动开启下载任务，下载的过程中通过进度block回传下载进度，下载完成后解码转码，调用下载完成回调block把image对象回传。</p><blockquote><p><strong>Step4</strong>：SDImageCache存储图片</p></blockquote><p>默认转码后的图片会缓存到内存中，如果同时需要缓存到磁盘上，才会开启异步IO队列通过NSFileManager把图片写入到本地磁盘，磁盘上图片的名字是经过MD5处理后的URLString。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if memory cache is enabled</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);</span><br><span class="line">    [<span class="keyword">self</span>.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (toDisk) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="built_in">NSData</span> *data = imageData;</span><br><span class="line">            <span class="keyword">if</span> (!data &amp;&amp; image) &#123;</span><br><span class="line">                <span class="comment">// If we do not have any data to detect image format, use PNG format</span></span><br><span class="line">                data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:SDImageFormatPNG];</span><br><span class="line">            &#125;</span><br><span class="line">            [<span class="keyword">self</span> storeImageDataToDisk:data forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)storeImageDataToDisk:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!imageData || !key) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> checkIfQueueIsIOQueue];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">        [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get cache Path for image key</span></span><br><span class="line">    <span class="built_in">NSString</span> *cachePathForKey = [<span class="keyword">self</span> defaultCachePathForKey:key];</span><br><span class="line">    <span class="comment">// transform to NSUrl</span></span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:cachePathForKey];</span><br><span class="line">    </span><br><span class="line">    [_fileManager createFileAtPath:cachePathForKey contents:imageData attributes:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// disable iCloud backup</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldDisableiCloud) &#123;</span><br><span class="line">        [fileURL setResourceValue:@YES forKey:<span class="built_in">NSURLIsExcludedFromBackupKey</span> error:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>这就是SDWebImage加载一张图片的大致流程了，其实SDWebImage里面做了很多细节优化处理。让我们接着往下look</strong></p></blockquote><p>####3、SDWebImage底层优化</p><ul><li>1、无效URL的处理<br><code>@property (strong, nonatomic, nonnull) NSMutableSet&lt;NSURL *&gt; *failedURLs;</code><br>SDWebImageManager维护了一个黑名单存放图片下载失败的URL，每次根据URLString查询图片的时候，会先去黑名单中查询，目标URL是否在黑名单中<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        <span class="comment">//为了线程安全</span></span><br><span class="line">        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</span><br><span class="line">            isFailedUrl = [<span class="keyword">self</span>.failedURLs containsObject:url];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>如果URL在黑名单中，直接执行回调Block，回传error，提高效率，避免不必要的操作。如果不被黑名单包含，继续正常流程，对应的URL下载失败后，把URL添加到黑名单<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (   <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorNotConnectedToInternet</span><br><span class="line">    &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorCancelled</span><br><span class="line">    &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorTimedOut</span><br><span class="line">    &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorInternationalRoamingOff</span><br><span class="line">    &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorDataNotAllowed</span><br><span class="line">    &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorCannotFindHost</span><br><span class="line">    &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorCannotConnectToHost</span><br><span class="line">    &amp;&amp; <span class="built_in">error</span>.<span class="built_in">code</span> != NSURLErrorNetworkConnectionLost) &#123;</span><br><span class="line">    <span class="comment">@synchronized (self.failedURLs) &#123;</span></span><br><span class="line"><span class="comment">        [self.failedURLs addObject:url];</span></span><br><span class="line"><span class="comment">   &#125; </span></span><br><span class="line"><span class="comment"> &#125;</span></span><br></pre></td></tr></table></figure></p><ul><li>2、高并发相同URL请求的处理<br><code>@property (strong, nonatomic, nonnull) NSMutableDictionary&lt;NSURL *, SDWebImageDownloaderOperation *&gt; *URLOperations;</code><br>SD内部每一个下载请求，对应一个SDWebImageDownloaderOperation，SDWebImageDownloader通过URLOperations属性来维护这个operation。<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</span><br><span class="line">    <span class="comment">//根据URLString查询是否有正在下载的操作</span></span><br><span class="line">    SDWebImageDownloaderOperation *operation = <span class="keyword">self</span>.URLOperations[url];</span><br><span class="line">    <span class="keyword">if</span> (!operation) &#123;</span><br><span class="line">        operation = createCallback();</span><br><span class="line">        <span class="comment">//把下载操作添加到URLOperations中</span></span><br><span class="line">        <span class="keyword">self</span>.URLOperations[url] = operation;</span><br><span class="line"></span><br><span class="line">        __<span class="keyword">weak</span> SDWebImageDownloaderOperation *woperation = operation;</span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line">            dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</span><br><span class="line">                SDWebImageDownloaderOperation *soperation = woperation;</span><br><span class="line">                <span class="keyword">if</span> (!soperation) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.URLOperations[url] == soperation) &#123;</span><br><span class="line">                    <span class="comment">//下完成后，把该URL的下载操作从URLOperations移除</span></span><br><span class="line">                    [<span class="keyword">self</span>.URLOperations removeObjectForKey:url];</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//已经有该URLString对应的下载任务存在，保存新任务的进度回调block和完成回调block</span></span><br><span class="line">    <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line"></span><br><span class="line">    token = [SDWebImageDownloadToken new];</span><br><span class="line">    token.url = url;</span><br><span class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>在<code>NSURLSessionDataDelegate</code>的<code>- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data</code>方法中可以看到如下代码<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> <span class="symbol">callbacksForKey:</span>kProgressCallbackKey]) &#123;</span><br><span class="line">    /<span class="regexp">/循环执行相同URL的进度回调Block</span></span><br><span class="line"><span class="regexp">    progressBlock(self.imageData.length, self.expectedSize, self.request.URL);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>简单的说，就是相同的URL只开启一个下载任务，在下载的过程中，把下载进度分别通知给该URL对应的其他操作，既节约流量、又兼顾所有任务的下载进度。下载完成的回调block同理执行。</p><ul><li>3、高并发不同URL请求的处理<br>UITableView的多个cell同时加载图片的时候，就会出现高并发的情况<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认最大并发数</span></span><br><span class="line">_downloadQueue.maxConcurrentOperationCount = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//session的初始化</span></span><br><span class="line"><span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfiguration</span><br><span class="line">                                                 delegate:<span class="keyword">self</span></span><br><span class="line">                                            delegateQueue:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>系统API对delegateQueue参数的描述是<code>If nil, the session creates a serial operation queue for performing all delegate method calls and completion handler calls.</code><br>SDWebImage的高并发下载任务是在一个并行队列，默认支持最大的并发数是6，默认并发任务执行顺序是FIFO（first in first out），如果设置任务的执行顺序为LIFO（last in first out）<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">    <span class="regexp">//</span> Emulate LIFO execution order <span class="keyword">by</span> systematically adding <span class="keyword">new</span> operations <span class="keyword">as</span> last operation<span class="string">'s dependency</span></span><br><span class="line"><span class="string">    //设置操作之间的依赖，新添加的operation被旧的operation依赖，来实现后进先出</span></span><br><span class="line"><span class="string">    [sself.lastAddedOperation addDependency:operation];</span></span><br><span class="line"><span class="string">    sself.lastAddedOperation = operation;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p><code>SDWebImageDownloader</code>在接收到<code>NSURLSessionDataDelegate</code>代理方法回调的时候，通过<code>NSURLSessionDataTask</code>获取到对应的<code>SDWebImageDownloaderOperation</code>，把delegate方法转发给<code>SDWebImageDownloaderOperation</code>，避免数据错乱。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">URLSession:</span>(NSURLSession *)session <span class="string">dataTask:</span>(NSURLSessionDataTask *)dataTask <span class="string">didReceiveData:</span>(NSData *)data &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Identify the operation that runs this task and pass it the delegate method</span></span><br><span class="line">    SDWebImageDownloaderOperation *dataOperation = [self <span class="string">operationWithTask:</span>dataTask];</span><br><span class="line">    <span class="comment">//把代理方法转发给SDWebImageDownloaderOperation</span></span><br><span class="line">    [dataOperation <span class="string">URLSession:</span>session <span class="string">dataTask:</span>dataTask <span class="string">didReceiveData:</span>data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据NSURLSessionTask获取对应的SDWebImageDownloaderOperation</span></span><br><span class="line">- (SDWebImageDownloaderOperation *)<span class="string">operationWithTask:</span>(NSURLSessionTask *)task &#123;</span><br><span class="line">    SDWebImageDownloaderOperation *returnOperation = nil;</span><br><span class="line">    <span class="keyword">for</span> (SDWebImageDownloaderOperation *operation <span class="keyword">in</span> self.downloadQueue.operations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operation.dataTask.taskIdentifier == task.taskIdentifier) &#123;</span><br><span class="line">            returnOperation = operation;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnOperation;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><ul><li>4、缓存管理策略<br>SDWebImage的内存管理由SDImageCache负责，分别监听了<strong>内存警告、应用将释放、进入后台</strong>三个通知<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span></span><br><span class="line">                                         <span class="selector-tag">selector</span>:@<span class="keyword">selector</span>(<span class="keyword">clearMemory</span>)</span><br><span class="line">                                             name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                           object:nil];</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span></span><br><span class="line">                                         <span class="selector-tag">selector</span>:@<span class="keyword">selector</span>(<span class="keyword">deleteOldFiles</span>)</span><br><span class="line">                                             name:UIApplicationWillTerminateNotification</span><br><span class="line">                                           object:nil];</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[[NSNotificationCenter defaultCenter]</span> <span class="selector-tag">addObserver</span><span class="selector-pseudo">:self</span></span><br><span class="line">                                         <span class="selector-tag">selector</span>:@<span class="keyword">selector</span>(<span class="keyword">backgroundDeleteOldFiles</span>)</span><br><span class="line">                                             name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                           object:nil];</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到内存警告通知，把内存中缓存的图片清空</span></span><br><span class="line">- (<span class="keyword">void</span>)clearMemory &#123;</span><br><span class="line">    [<span class="meta">self.memCache removeAllObjects</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SDImageCache图片磁盘缓存的时长默认是1周<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static const NSInteger kDefaultCacheMaxCacheAge = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>; <span class="comment">// 1 week</span></span><br></pre></td></tr></table></figure></p><p>在每次收到<strong>进入后台、应用将要释放</strong>通知后，SDWebImage会检查磁盘上的图片，如果过期就清理<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove files that are older than the expiration date;</span></span><br><span class="line"><span class="comment">//如果图片过期，记录过期图片URL</span></span><br><span class="line">NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];</span><br><span class="line"><span class="keyword">if</span> ([[modificationDate <span class="string">laterDate:</span>expirationDate] <span class="string">isEqualToDate:</span>expirationDate]) &#123;</span><br><span class="line">    [urlsToDelete <span class="string">addObject:</span>fileURL];</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环删除过期图片</span></span><br><span class="line"><span class="keyword">for</span> (NSURL *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</span><br><span class="line">    [_fileManager <span class="string">removeItemAtURL:</span>fileURL <span class="string">error:</span>nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果设置最大的缓存空间，在收到<strong>进入后台、应用将要释放</strong>通知后，判断使用当前空间使用超过设置的最大空间的50%后，开始清理，按照修改时间排序后，从修改时间最早的开始清理，直到使用空间小于缓存空间50%后结束。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If our remaining disk cache exceeds a configured maximum size, perform a second</span></span><br><span class="line"><span class="comment">// size-based cleanup pass.  We delete the oldest files first.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.config.maxCacheSize &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span>.config.maxCacheSize) &#123;</span><br><span class="line">    <span class="comment">// Target half of our maximum cache size for this cleanup pass.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span>.config.maxCacheSize / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sort the remaining cache files by their last modification time (oldest first).</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></span><br><span class="line">                                                             usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</span><br><span class="line">                                                                 <span class="keyword">return</span> [obj1[<span class="built_in">NSURLContentModificationDateKey</span>] compare:obj2[<span class="built_in">NSURLContentModificationDateKey</span>]];</span><br><span class="line">                                                             &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delete files until we fall below our desired cache size.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *resourceValues = cacheFiles[fileURL];</span><br><span class="line">            <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">            currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>5、解码转码<br><img src="http://upload-images.jianshu.io/upload_images/1890873-737b0832f74ae9a8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p>说实话，解码转码这块看的还不太明白，等我看明白了，再回来补上…</p>]]></content>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UIWebView的加载进度条</title>
      <link href="/2017/03/17/UIWebView%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
      <url>/2017/03/17/UIWebView%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
      <content type="html"><![CDATA[<h3 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h3><p>在一个阳光明媚的午后，组织终于决定把公司的SDK产品，由Native更换成H5，你没看错，就是用Native界面做的SDK，说多了都是眼泪。产品说，网页加载的时候要有进度条，OK，没问题，一个字就是<strong>“干”</strong>，你懂的。</p><blockquote><p>现在的iOS 应用中，或多或少都会有H5页，因为H5有Native所不具备的灵活性，比如应用中的活动展示，需要不定时的更新，使用H5来做就能轻松搞定！iOS中常用的H5容器有两种：<em>1、 UIWebView 2、WKWebView。</em></p><ul><li><strong>WKWebView</strong> 是<strong>iOS8.0</strong>以后开放的API，可以通过KVO来监听<code>estimatedProgress</code>属性的变化来获取当前网页的加载进度，如果你的项目不用适配iOS6、iOS7<em>（太爽了，幸福感爆棚有木有），</em>那么你可以很easy的做一个WebView的进度条。</li><li><strong>UIWebView</strong> 如果你的应用需要适配iOS7、或者iOS6 或者更早😂。UIWebView是你不二的<em>（也是唯一的）</em>选择，查看系统的API后并没有发现可以获取加载进度的途径，so…你看到的网页有加载进度，如果它是用UIWebView加载的，那进度条一定是 <strong>假的！ 假的！假的！😁</strong></li></ul></blockquote><p>应商户要求，SDK最低需要支持iOS6.0，然而组织并没有6.0系统的测试机，领导决定，把SDK最低支持的系统为设为6.0，虽然没有真机试过，到底能不能在6.0系统上使用也未知，鉴于这些，H5只能通过UIWebView来加载了。</p><p>####废话不多说，先来个成品的效果图：</p><h5 id="效果1"><a href="#效果1" class="headerlink" title="效果1 "></a>效果1 <img src="http://upload-images.jianshu.io/upload_images/1890873-e45931be0265dd9b.gif?imageMogr2/auto-orient/strip" alt="图片1"></h5><h5 id="效果2"><a href="#效果2" class="headerlink" title="效果2"></a>效果2<img src="http://upload-images.jianshu.io/upload_images/1890873-8a38ca6ae4a898fb.gif?imageMogr2/auto-orient/strip" alt="图片2"></h5><p><a href="https://github.com/jindk/WebViewProgress" target="_blank" rel="noopener">Demo下载链接</a></p><h4 id="1、第一次尝试"><a href="#1、第一次尝试" class="headerlink" title="1、第一次尝试"></a>1、第一次尝试</h4><p>进度条嘛，第一反应就是用系统的<code>UIProgressView</code>，然而试过之后才发现系统的<code>UIProgressView</code>限制太多，可以自定义的太少了，所以就放弃了。</p><h4 id="2、第二次尝试"><a href="#2、第二次尝试" class="headerlink" title="2、第二次尝试"></a>2、第二次尝试</h4><p>百度、Google一番，好多道友都建议使用CAShapeLayer来做，好吧，<strong>干！</strong><br>查看系统CAShapeLayer的API发现，CAShapeLayer有两个属性<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* These values define <span class="keyword">the</span> subregion <span class="keyword">of</span> <span class="keyword">the</span> path used <span class="keyword">to</span> draw <span class="keyword">the</span></span><br><span class="line"> * stroked outline. The values must be <span class="keyword">in</span> <span class="keyword">the</span> range [<span class="number">0</span>,<span class="number">1</span>] <span class="keyword">with</span> zero</span><br><span class="line"> * representing <span class="keyword">the</span> start <span class="keyword">of</span> <span class="keyword">the</span> path <span class="keyword">and</span> one <span class="keyword">the</span> <span class="keyword">end</span>. Values <span class="keyword">in</span></span><br><span class="line"> * <span class="keyword">between</span> zero <span class="keyword">and</span> one are interpolated linearly along <span class="keyword">the</span> path</span><br><span class="line"> * <span class="built_in">length</span>. strokeStart defaults <span class="keyword">to</span> zero <span class="keyword">and</span> strokeEnd <span class="keyword">to</span> one. Both are</span><br><span class="line"> * animatable. */</span><br><span class="line">@<span class="keyword">property</span> CGFloat strokeStart;</span><br><span class="line">@<span class="keyword">property</span> CGFloat strokeEnd;</span><br></pre></td></tr></table></figure></p><p>意思就是CAShapeLayer的设置这两个描边的起始和结束位置是有<strong>动画效果</strong>的<br>自定一个类DKProgressLayer继承自CAShapeLayer</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define DEVICE_WIDTH [UIScreen mainScreen].bounds.size.width</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DKProgressLayer</span> : <span class="title">CAShapeLayer</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *progressColor;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 进度条开始加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)progressAnimationStart;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 进度条加载完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)progressAnimationCompletion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DKProgressLayer</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> stepWidth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> progressInterval = <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DKProgressLayer</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.progressColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">        <span class="keyword">self</span>.stepWidth = <span class="number">0.01</span>;</span><br><span class="line">        <span class="keyword">self</span>.lineWidth = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">        [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">2</span>)];</span><br><span class="line">        [path addLineToPoint:<span class="built_in">CGPointMake</span>(DEVICE_WIDTH, <span class="number">2</span>)];</span><br><span class="line">        <span class="keyword">self</span>.path = path.CGPath;</span><br><span class="line">        <span class="keyword">self</span>.strokeEnd = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setProgressColor:(<span class="built_in">UIColor</span> *)progressColor &#123;</span><br><span class="line">    <span class="keyword">if</span> (!progressColor) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _progressColor = progressColor;</span><br><span class="line">    <span class="keyword">self</span>.progressColor = progressColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不断设置layer描边的结束位置 */</span></span><br><span class="line">- (<span class="keyword">void</span>)progressChanged:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="keyword">self</span>.strokeEnd += _stepWidth;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span>.strokeEnd &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">          _stepWidth = <span class="number">0.0001</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)progressAnimationStart &#123;</span><br><span class="line">    <span class="keyword">self</span>.hidden = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (_timer) &#123;</span><br><span class="line">        [<span class="keyword">self</span> invalidateTimer];</span><br><span class="line">    &#125;</span><br><span class="line">    _timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:progressInterval target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(progressChanged:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)progressAnimationCompletion &#123;</span><br><span class="line">    [<span class="keyword">self</span> invalidateTimer];</span><br><span class="line">    <span class="keyword">self</span>.strokeEnd = <span class="number">1.0</span>;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.25</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.hidden = <span class="literal">YES</span>;</span><br><span class="line">        _stepWidth = <span class="number">0.01</span>;</span><br><span class="line">        <span class="keyword">self</span>.strokeEnd = <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invalidateTimer &#123;</span><br><span class="line">    [_timer invalidate];</span><br><span class="line">    _timer = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>好吧，效果来了：<img src="http://upload-images.jianshu.io/upload_images/1890873-e45931be0265dd9b.gif?imageMogr2/auto-orient/strip" alt="图片3"><br>So easy too Happy，拿给产品去看……</p><blockquote><p>产品：这也太low了吧<br>猿：握草，微信的效果就是这样好不好，丝般顺滑。<br>产品：不行，太大众化了，改成一边加载一边渐变的，前边加载，后边渐隐的<br>猿：尼玛……那不就是QQ的加载效果么，那就不low了吗？<br>产品：我就要那样的效果，你就告诉我能不能做？<br>猿：你大爷……</p></blockquote><h4 id="3、第三次尝试"><a href="#3、第三次尝试" class="headerlink" title="3、第三次尝试"></a>3、第三次尝试</h4><p>继续百度、Google，并没有发现很好的思路，快要绝望的时候发现CAShapeLayer有一个子类CAGradientLayer<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/* The array <span class="keyword">of</span> CGColorRef objects defining the color <span class="keyword">of</span> <span class="keyword">each</span> gradient</span><br><span class="line"> * <span class="keyword">stop</span>. Defaults <span class="keyword">to</span> nil. Animatable. */</span><br><span class="line"></span><br><span class="line">@<span class="keyword">property</span>(nullable, copy) NSArray *colors;</span><br><span class="line"></span><br><span class="line">/* An <span class="keyword">optional</span> array <span class="keyword">of</span> NSNumber objects defining the location <span class="keyword">of</span> <span class="keyword">each</span></span><br><span class="line"> * gradient <span class="keyword">stop</span> <span class="keyword">as</span> a value <span class="keyword">in</span> the range [<span class="number">0</span>,<span class="number">1</span>]. The values must be</span><br><span class="line"> * monotonically increasing. <span class="keyword">If</span> a nil array <span class="keyword">is</span> given, the stops are</span><br><span class="line"> * assumed <span class="keyword">to</span> spread uniformly across the [<span class="number">0</span>,<span class="number">1</span>] range. <span class="keyword">When</span> rendered,</span><br><span class="line"> * the colors are mapped <span class="keyword">to</span> the output colorspace before being</span><br><span class="line"> * interpolated. Defaults <span class="keyword">to</span> nil. Animatable. */</span><br><span class="line"></span><br><span class="line">@<span class="keyword">property</span>(nullable, copy) NSArray&lt;NSNumber *&gt; *locations;</span><br><span class="line"></span><br><span class="line">/* The start <span class="keyword">and</span> <span class="keyword">end</span> points <span class="keyword">of</span> the gradient <span class="keyword">when</span> drawn <span class="keyword">into</span> the layer<span class="comment">'s</span></span><br><span class="line"> * coordinate space. The start point corresponds <span class="keyword">to</span> the first gradient</span><br><span class="line"> * <span class="keyword">stop</span>, the <span class="keyword">end</span> point <span class="keyword">to</span> the last gradient <span class="keyword">stop</span>. Both points are</span><br><span class="line"> * defined <span class="keyword">in</span> a unit coordinate space that <span class="keyword">is</span> <span class="keyword">then</span> mapped <span class="keyword">to</span> the</span><br><span class="line"> * layer<span class="comment">'s bounds rectangle when drawn. (I.e. [0,0] is the bottom-left</span></span><br><span class="line"> * corner <span class="keyword">of</span> the layer, [<span class="number">1</span>,<span class="number">1</span>] <span class="keyword">is</span> the top-right corner.) The <span class="keyword">default</span> values</span><br><span class="line"> * are [<span class="number">.5</span>,<span class="number">0</span>] <span class="keyword">and</span> [<span class="number">.5</span>,<span class="number">1</span>] respectively. Both are animatable. */</span><br><span class="line"></span><br><span class="line">@<span class="keyword">property</span> CGPoint startPoint;</span><br><span class="line">@<span class="keyword">property</span> CGPoint endPoint;</span><br></pre></td></tr></table></figure></p><p>看注释，貌似能设置起始点、终点，还能设置多种颜色，还能设置颜色的位置，我凑，这不就能满足产品🐶的需求了吗？ 快试试……此处省略过程，直接贴代码了<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setProgressStyle:(DKProgressStyle)progressStyle &#123;</span><br><span class="line">    _progressStyle = progressStyle;</span><br><span class="line">    <span class="keyword">if</span> (progressStyle == DKProgressStyle_Gradual) &#123;</span><br><span class="line">        <span class="keyword">self</span>.strokeColor = <span class="literal">nil</span>;</span><br><span class="line">        <span class="built_in">CAGradientLayer</span> *gradientLayer = [<span class="built_in">CAGradientLayer</span> layer];</span><br><span class="line">        <span class="built_in">CGFloat</span> RGB[<span class="number">3</span>];</span><br><span class="line">        [<span class="keyword">self</span> getRGBComponents:RGB forColor:_progressColor];</span><br><span class="line">        gradientLayer.colors = @[(__bridge <span class="keyword">id</span>)[<span class="built_in">UIColor</span> colorWithRed:RGB[<span class="number">0</span>] green:RGB[<span class="number">1</span>] blue:RGB[<span class="number">2</span>] alpha:<span class="number">0.2</span>].CGColor, (__bridge <span class="keyword">id</span>)_progressColor.CGColor];</span><br><span class="line">        gradientLayer.locations = @[@(<span class="number">0</span>), @(<span class="number">0</span>)];</span><br><span class="line">        gradientLayer.startPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        gradientLayer.endPoint = <span class="built_in">CGPointMake</span>(<span class="number">1.0</span>, <span class="number">0</span>);</span><br><span class="line">        gradientLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        _gradientLayer = gradientLayer;</span><br><span class="line">        [<span class="keyword">self</span> addSublayer:gradientLayer];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)progressChanged:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="keyword">self</span>.strokeEnd += _stepWidth;</span><br><span class="line">    <span class="comment">/* 超过90% 减缓进度条增长速度 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.strokeEnd &gt; <span class="number">0.9</span>) &#123;</span><br><span class="line">        _stepWidth = <span class="number">0.0001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_progressStyle == DKProgressStyle_Gradual) &#123;</span><br><span class="line">        <span class="comment">/* 不断改变layer颜色的起始位置 */</span></span><br><span class="line">        _gradientLayer.locations = @[@(<span class="keyword">self</span>.strokeEnd/<span class="number">2</span>), @(<span class="keyword">self</span>.strokeEnd)];</span><br><span class="line">        <span class="comment">/* 不断改变layer的frame */</span></span><br><span class="line">        _gradientLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, DEVICE_WIDTH*<span class="keyword">self</span>.strokeEnd, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取颜色的RGB值 */</span></span><br><span class="line">- (<span class="keyword">void</span>)getRGBComponents:(<span class="built_in">CGFloat</span> [<span class="number">3</span>])components forColor:(<span class="built_in">UIColor</span> *)color &#123;</span><br><span class="line">    <span class="keyword">if</span> (!color) &#123;</span><br><span class="line">        components[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        components[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        components[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> rgbColorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> resultingPixel[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(&amp;resultingPixel, <span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, rgbColorSpace, kCGImageAlphaNoneSkipLast);</span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, [color <span class="built_in">CGColor</span>]);</span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(rgbColorSpace);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> component = <span class="number">0</span>; component &lt; <span class="number">3</span>; component++) &#123;</span><br><span class="line">        components[component] = resultingPixel[component] / <span class="number">255.0</span>f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果如下：<img src="http://upload-images.jianshu.io/upload_images/1890873-8a38ca6ae4a898fb.gif?imageMogr2/auto-orient/strip" alt="图片"></p><blockquote><p>产品：这么简单的一个东西，你弄这么久，先这么着吧，有什么想法再找你<br>猿：我日尼玛，傻吊……</p></blockquote><p>好吧，这个需求就暂时告一段落了，产品需求来了再改吧😂</p><p><a href="https://github.com/jindk/WebViewProgress" target="_blank" rel="noopener">本文github链接</a>，如果你觉得能帮到你，路过给个Star哈。</p><p>######参考链接：<br><a href="http://www.jianshu.com/p/b32b9fb6cb0a" target="_blank" rel="noopener">http://www.jianshu.com/p/b32b9fb6cb0a</a>  感谢作者的思路</p>]]></content>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 文本高度计算</title>
      <link href="/2016/04/11/iOS%20%E6%96%87%E6%9C%AC%E9%AB%98%E5%BA%A6%E8%AE%A1%E7%AE%97/"/>
      <url>/2016/04/11/iOS%20%E6%96%87%E6%9C%AC%E9%AB%98%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
      <content type="html"><![CDATA[<p>iOS开发的过程中，总是避免不了各种高度的自适应，如：UILabel、UITextView、UITableViewCell的高度自适应…而这些适应大部分都源自文本的适应。<br>计算文本高度的方法有很多种，而我们平时的使用中，富文本的使用几率要大于普通文本，下面以富文本为例介绍两种获取文本高度的方式：<br><a id="more"></a></p><blockquote><p>第一种：通过UILabel获取文本的高度<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"朱雀桥边野草花，乌衣巷口夕阳斜。旧时王谢堂前燕，飞入寻常百姓家。"</span>;</span><br><span class="line"><span class="built_in">NSMutableAttributedString</span> *attributeString = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:str];</span><br><span class="line"><span class="built_in">NSMutableParagraphStyle</span> *style = [[<span class="built_in">NSMutableParagraphStyle</span> alloc] init];</span><br><span class="line">style.lineSpacing = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">14</span>];</span><br><span class="line">[attributeString addAttribute:<span class="built_in">NSParagraphStyleAttributeName</span> value:style range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, str.length)];</span><br><span class="line">[attributeString addAttribute:<span class="built_in">NSFontAttributeName</span> value:font range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, str.length)];</span><br><span class="line"><span class="built_in">UILabel</span> *label = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">1</span>)];</span><br><span class="line">label.font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">14</span>];</span><br><span class="line">label.numberOfLines = <span class="number">0</span>;</span><br><span class="line">label.attributedText = attributeString;</span><br><span class="line"><span class="built_in">CGSize</span> size = [label sizeThatFits:<span class="built_in">CGSizeMake</span>(label.frame.size.width, <span class="built_in">CGFLOAT_MAX</span>)];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"size:%@"</span>, <span class="built_in">NSStringFromCGSize</span>(size));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"label.frame.size:%@"</span>, <span class="built_in">NSStringFromCGSize</span>(label.frame.size));</span><br></pre></td></tr></table></figure></p></blockquote><p>可以看到打印结果为:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size:&#123;<span class="number">196</span>, <span class="number">70.5</span>&#125;</span><br><span class="line"><span class="selector-tag">label</span><span class="selector-class">.frame</span><span class="selector-class">.size</span>:&#123;<span class="number">200</span>, <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></p><p>在label调用完<code>sizeThatFits:</code>之后，会返回根据条件适应好的size(本身的size并不发生改变)，可以通过size.height拿到文本适应后的高度。<br>但是这种方法有些时候取到的高度会有问题，比如要显示的文本为：@”朱雀桥边野草花”时，上面的代码打印的结果为：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size:&#123;<span class="number">98</span>, <span class="number">27</span>&#125;  <span class="comment">//单行高度包含了行间距</span></span><br><span class="line"><span class="selector-tag">label</span><span class="selector-class">.frame</span><span class="selector-class">.size</span>:&#123;<span class="number">200</span>, <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></p><p>由于上面的代码显示的文本是富文本，文本的高度包含文字高度的同时，还包含有行间距，但是当UILabel显示的内容为1行时，label调用完<code>sizeThatFits:</code>之后返回的size高度是包含行间距的。</p><p>当UILabel显示的文本行数大于等于2行时，sizeThatFits:后拿到的高度是准确的，当UILabel显示的文本行数是1行时，拿到的高度需要减去行间距后才是正确的适应高度</p><blockquote><p>第二种：调用字符串的<code>boundingRectWithSize</code>获取文本的高度<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"朱雀桥边野草花，乌衣巷口夕阳斜。旧时王谢堂前燕，飞入寻常百姓家。"</span>;</span><br><span class="line"><span class="built_in">NSMutableAttributedString</span> *attributeString = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:str];</span><br><span class="line"><span class="built_in">NSMutableParagraphStyle</span> *style = [[<span class="built_in">NSMutableParagraphStyle</span> alloc] init];</span><br><span class="line">style.lineSpacing = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">14</span>];</span><br><span class="line">[attributeString addAttribute:<span class="built_in">NSParagraphStyleAttributeName</span> value:style range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, str.length)];</span><br><span class="line">[attributeString addAttribute:<span class="built_in">NSFontAttributeName</span> value:font range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, str.length)];</span><br><span class="line"><span class="built_in">NSStringDrawingOptions</span> options = <span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> | <span class="built_in">NSStringDrawingUsesFontLeading</span>;</span><br><span class="line"><span class="built_in">CGRect</span> rect = [attributeString boundingRectWithSize:<span class="built_in">CGSizeMake</span>(<span class="number">200</span>, <span class="built_in">CGFLOAT_MAX</span>) options:options context:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"size:%@"</span>, <span class="built_in">NSStringFromCGSize</span>(rect.size));</span><br></pre></td></tr></table></figure></p></blockquote><p>可以看到打印结果为:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>:&#123;<span class="number">196</span>, <span class="number">70.12109375</span>&#125;</span><br></pre></td></tr></table></figure></p><p>要显示的文本为：@”朱雀桥边野草花”时，上面的代码打印的结果为：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>:&#123;<span class="number">98</span>, <span class="number">26.70703125</span>&#125;  <span class="comment">//单行文本的行高同样包含行间距</span></span><br></pre></td></tr></table></figure></p><p>以上两种方式都能获取到文本的高度，同样在显示富文本时，如果文本的行数是1行，获取到的文本高度都有问题，我们期望得到的是文本的高度（不包含行间距），这时候就需要判断了。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文本的高度减去字体高度小于等于行间距，判断为当前只有1行</span></span><br><span class="line"><span class="built_in">if</span> ((<span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">height</span> - font.lineHeight) &lt;= style.lineSpacing) &#123;</span><br><span class="line">  <span class="built_in">rect</span> = CGRectMake(<span class="built_in">rect</span>.origin.x, <span class="built_in">rect</span>.origin.y, <span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">width</span>, <span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">height</span>-style.lineSpacing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里当文本只有1行时，获取准确的高度的问题好像得到了解决。当现实的文本是@”朱雀桥边野草花”时，打印的结果为：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>:&#123;<span class="number">98</span>, <span class="number">26.70703125</span>&#125;  <span class="comment">//加判断条件之前</span></span><br><span class="line"><span class="built_in">size</span>:&#123;<span class="number">98</span>, <span class="number">16.70703125</span>&#125;  <span class="comment">//加判断条件之后</span></span><br></pre></td></tr></table></figure></p><p>获取的高度确实为字体的高度，不包含行间距了，然而在测试的时候悲催的发现，当显示文本是@”sfklsdkfjsdlfjsdjfd”时，纯英文的一段测试数据，上面代码的打印结果为：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size:&#123;<span class="number">113</span>.<span class="number">4013671875</span>, <span class="number">6.70703125</span>&#125;</span><br></pre></td></tr></table></figure></p><p>唉，我去，高度怎么变成这么点儿了？在反复测试之后发现，只要文本中包含有中文时，计算<strong>单行文本</strong>高度就包含行间距，在文本是纯英文时，<strong>单行文本</strong>的高度不包含行间距（注：2行或2行以上的纯英文计算的高度是没问题的）,so…判断条件又变成了下边这样：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">height</span> - _font.lineHeight) &lt;= paragraphStyle.lineSpacing) &#123;</span><br><span class="line">  <span class="keyword">if</span> ([self containChinese:<span class="built_in">str</span>]) &#123;  <span class="comment">//如果包含中文</span></span><br><span class="line">    <span class="built_in">rect</span> = CGRectMake(<span class="built_in">rect</span>.origin.x, <span class="built_in">rect</span>.origin.y, <span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">width</span>, <span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">height</span>-paragraphStyle.lineSpacing);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断如果包含中文</span></span><br><span class="line">- (BOOL)containChinese:(NSString *)<span class="built_in">str</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt; [<span class="built_in">str</span> length];i++)&#123;</span><br><span class="line">    <span class="built_in">int</span> a = [<span class="built_in">str</span> characterAtIndex:i];</span><br><span class="line">    <span class="keyword">if</span>( a &gt; <span class="number">0x4e00</span> &amp;&amp; a &lt; <span class="number">0x9fff</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里问题就算是解决了，由于笔者能力有限，只会利用现掌握的知识解决这种问题，如果有大神有好的办法，还望不吝赐教，分享一下！</p>]]></content>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>大家好，我是XXX。欢迎来到我的个人技术博客。</p><p>这里用markdown写下你的简介，就跟平时写md一样就可以了。</p>]]></content>
    </entry>
    
  
</search>
